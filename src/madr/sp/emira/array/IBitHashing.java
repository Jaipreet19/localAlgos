package madr.sp.emira.array;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;

public class IBitHashing {

	public static void main(String[] args) {
		IBitHashing cl = new IBitHashing();		
		/*Integer[] a = {34, 63, 64, 38, 65, 83, 50, 44, 18, 34, 71, 80, 22, 28, 20, 96, 33, 70, 0, 25, 64, 96, 18, 2, 53, 100, 24, 47, 98, 69, 60, 55, 8, 38, 72, 94, 18, 68, 0, 53, 18, 30, 86, 55, 13, 93, 15, 43, 73, 68, 29};
		System.out.println(cl.diffPossible(BinarySearchClass.createListWrapper(a), 0));*/
		
		/*Integer[] i = {0, 22, 7, 21, -11, -6, -7, -16, -2};//{-19, 8, 2, -8, 19, 5, -2, -23};//{1, 2, -3, 3};//{1, 2, -2, 4, -4};
		System.out.println(cl.longestSubsequenceSumZero(BinarySearchClass.createListWrapper(i)));*/
		
		/*String str = "Wnb9z9dMc7E8v1RTUaZPoDNIAXRlzkqLaa97KMWLzbitaCkRpiE4J4hJWhRcGnC8H6mwasgDfZ76VKdXhvEYmYrZY4Cfmf4HoSlchY"+"WFEb1xllGKyEEmZOLPh1V6RuM7Mxd7xK72aNrWS4MEaUmgEn7L4rW3o14"+"Nq9l2EN4HH6uJWljI8a5irvuODHY7A7ku4PJY2anSWnfJJE1w8p12Ks3oZRxAF3atqGBlzVQ0gltOwYmeynttUmQ4QBDLDrS4zn4VRZLosOITo4JlIqPD6t4NjhHThOjJxpMp9fICkrgJeGiDAwsb8a3I7Txz5BBKV9bEfMsKNhCuY3W0ZHqY0MhBfz1CbYCzwZZdM4p65ppP9s5QJcfjadmMMi26JKz0TVVwvNA8LP5Vi1QsxId4SI19jfcUH97wmZu0pbw1zFtyJ8GAp5yjjQTzFIboC1iRzklnOJzJld9TMaxqvBNBJKIyDjWrdfLOY8FGMOcPhfJ97Dph35zfxYyUf4DIqFi94lm9J0skYqGz9JT0kiAABQZDazZcNi80dSSdveSl6h3dJjHmlK8qHIlDsqFd5FMhlEirax8WA0v3NDPT8vPhwKpxcnVeu14Gcxr3h1wAXXV0y7Xy9qqB2NQ5HQLJ7cyXAckEYHsLCPSy28xcdNJatx1KLWohOQado4WywJbGvsFR17rKmvOPABweXnFD3odrbSMD4Na4nuBBswvMmFRTUOcf7jZi4z5JnJqXz6hitaPnaEtjoSEBq82a52nvqYy7hhldBoxen2et2OMadVEHeTYLL7GLsIhTP6UizHIuzcJMljo4lFgW5AyrfUlIBPAlhwaSiJtTvcbVZynDSM6RO1PqFKWKg2MHIgNhjuzENg2oFCfW7z5KJvEL9qWqKzZNc0o3BMRjS04NCHFvhtsteQoQRgz84XZBHBJRdekCdcVVXu9c01gYRAz7oIAxN3zKZb64EFKssfQ4HW971jv3H7x5E9dAszA0HrKTONyZDGYtHWt4QLhNsIs8mo4AIN7ecFKewyvGECAnaJpDn1MTTS4yTgZnm6N6qnmfjVt6ZU51F9BxH0jVG0kovTGSjTUkmb1mRTLQE5mTlVHcEz3yBOh4WiFFJjKJdi1HBIBaDL4r45HzaBvmYJPlWIomkqKEmQ4rLAbYG7C5rFfpMu8rHvjU7hP0JVvteGtaGn7mqeKsn7CgrJX1tb8t0ldaS3iUy8SEKAo5IZHNKOfEaij3nI4oRVzeVOZsH91pMsA4jRYgEohubPW8ciXwVrFi1qEWjvB8gfalyP60n1fHyjsiLW0T5uY1JzQWHKCbLVh7QFoJFAEV0L516XmzIo556yRH1vhPnceOCjebqgsmO78AQ8Ir2d4pHFFHAGB9lESn3OtJye1Lcyq9D6X93UakA3JKVKEt6JZDLVBMp4msOefkPKSw59Uix9d9kOQm8WCepJTangdNSOKaxblZDNJ5eHvEroYacBhd9UdafEitdF3nfStF7AhkSfQVC61YWWkKTNdx96OoJGTnxuqt4oFZNFtO7aMuN3IJAkw3m3kgZFRGyd3D3wweagNL9XlYtvZwejbjpkDOZz33C0jbEWaMEaUPw6BG49XqyQoUwtriguO0yvWyaJqD4ye3o0E46huKYAsdKAq6MLWMxF6tfyPVaoqOGd0eOBHbAF89XXmDd4AIkoFPXkAOW8hln5nXnIWP6RBbfEkPPbxoToMbV";
		System.out.println(cl.lengthOfLongestSubstring(str));*/
		
		/*int[] arr = {1,0,-1,0,-2, 2};
		System.out.println(cl.fourSum(BinarySearchClass.createList(arr), 0));*/
		
		/*char[] arr = "cat".toCharArray();
		Arrays.sort(arr);
		System.out.println(String.valueOf(arr));*/
		
		/*int[] arr = {9, 5, 4, 9, 3, 6, 8, 7, 1, 2, 8, 7, 2, 9, 7, 1, 3, 9, 7, 8, 1, 0, 5, 5};
		System.out.println(cl.equal_AB_CD(BinarySearchClass.createList(arr)));*/
		
		//System.out.println(cl.minWindow("TquFYBhPdnv7B40ibLTOIaKFVPpzaTx6z5svvfHI02Ul050z0fMC2gmuHDoV8mfVSecxZKink1fdgcFO7IqzSbr15xUXkixHRyUs0PGBHrMQeCEsVPa7z4N55VDSIzKjRFcqMai1i3LfPhwRavhMN28ZCo4rnyh0Nyjicdwf6w5krmUguK13WSsGIwdDwH7Rqy2a8iQ0s0yhWXGsrUny05GVq1hwvMKcg2MASfKj6a7csLe5NPYX5BuIdfbFQSuLQ2jViwylwOhQUOqsqcYVVE0mra3MCa54hbs5K4ChOSmaUuNgmY1tn25j2aSfJp5MywnA4csDNd6AgdxvjdZr3OLIwiDL69r6O3dS4eNfWK4dTVsh3bT0XR8ZYcnvQ0A8YIHK9LjuYwVGomGcM2IRnwI4zR28APMWIithrHGGF5gyEWuhZLTJOfpegMUmDLziS4KeOjUiQZ0lJij1frdYqxowUu4RECiX9mBLMxx2mJRJf6dfHQ9pAxCGVxP4rKk3Bgyyhpu17iK2mjVuLCg9qnfpjBkhhCpFQ8iHXQ6g67rusAx9jmeGuPfSdxg1FgFG6X223dxEsKUlUJEhndb6eycnSQiovC5oWDiNTEmWK7YfmfBZP1HXaKLSLfmwy2Uhr68Td", "dB"));
		
		//System.out.println(cl.fractionToDecimal(2, 42343)); //(2, 42343)
		
		int[] a = {0,0,1,-1};//{-6, 5, -18, 2, 5, -2,};
		int[] b = {0,0,1,-1};//{-17, -16, -17,-4, -13, 20};
		System.out.println(cl.maxPoints(BinarySearchClass.createList(a), BinarySearchClass.createList(b)));
	}
	
	
	/**
	 * Given n points on a 2D plane, find the maximum number of points that lie on the same straight line.
	 * 
	 * @param a
	 * @param b
	 * @return
	 */
	public int maxPoints(List<Integer> a, List<Integer> b) {
	    if (a == null || b == null) return 0;
	    if (a.size() <= 2) return a.size();
	    int len = a.size();
	    Map<Pair, Pair> map = new HashMap<Pair, Pair>();
	    int maxCount = 0;
	    int localCount = 2;
	    for (int i=0; i<len-1; i++) {
	        for (int j = i+1; j<len; j++) {
	            int slopeN = b.get(j) - b.get(i);
	            int slopeD = a.get(j) - a.get(i);
	            int gcd = gcd(slopeN,slopeD);
	            slopeN = gcd != 0 ? slopeN/gcd : -313213;
	            slopeD = gcd != 0 ? slopeD/gcd : -313213;
	            Pair slope = new Pair(slopeN, slopeD);
	            //double slope = round((double)slopeN/(double)slopeD);
	            if (map.containsKey(slope) /*&& !map.get(slope).equals(x1y1)*/) {
	                localCount++;
	            } else {
	            	Pair xy = new Pair(a.get(i),b.get(i));
	                map.put(slope,xy);
	            }
	        }
	        maxCount = maxCount > localCount ? maxCount : localCount;
	        localCount = 2;
	    }
	    return maxCount;
	}
	
	public int gcd(int a, int b) {
		if (a == 0) return b;
		else return gcd(b>a?b-a:a-b,a);
	}
	
	double round(double val) {
	    double scale = 100000d;
        return Math.round(val * scale) / scale;
	}
	
	class Pair {
	    Integer x;
	    Integer y;
	    
	    public Pair(int x, int y) {
	        this.x = x;
	        this.y = y;
	    }
	    
	    @Override
	    public String toString() {
	    	return "{"+x+":"+y+"}";
	    }
	    
	    @Override
	    public int hashCode() {
	        int result = 17;
	        result = 31 * result + x.hashCode();
	        result = 31 * result + y.hashCode();
	        return result;
	    }
	    
	    @Override
    	public boolean equals(Object o) {
	    	if (o == this) return true;
	        if (!(o instanceof Pair)) {
	            return false;
	        }

	        Pair p = (Pair) o;

	        return p.x.equals(x) && p.y.equals(y);
    	}
	}
	
	/**
	 * A/B  
	 * @param A
	 * @param B
	 * @return
	 */
	public String fractionToDecimal(int A, int B) {
        if (A == 0) return 0+"";
        StringBuilder sb = new StringBuilder();
        if (A < 0 || B < 0) {
            if (!(A<0 && B<0)) sb.append('-');
        }
        long a = A; a = Math.abs(a); 
        long b = B; b = Math.abs(b);
        sb.append(a/b);
        if (a%b == 0) return sb.toString();
        Map<Long, Integer> map = new HashMap<Long, Integer>();
        int index = 1;
        long rem = a%b;
        sb.append('.');
        while (rem != 0) {
        	rem = rem*10;
        	long t = rem/b;
        	rem = rem%b;
        	if (map.containsKey(rem)) {
        		int i = map.get(rem);
                int pos = sb.indexOf(".")+i;
                if (sb.charAt(pos) != t+'0') {
                	sb.append(t);
            		map.put(rem, index++);
                } else {
                	String str = sb.substring(pos);
                	String begin = sb.substring(0,pos);
                	return begin+"("+str+")";
                }
        	} else {
        		sb.append(t);
        		map.put(rem, index++);
        	}
        }
        return sb.toString();
    }
	
	/**
	 * Given a string S and a string T, find the minimum window in S which will contain all the characters in T in linear time complexity.
		Note that when the count of a character C in T is N, then the count of C in minimum window in S should be at least N.
		
		Example :
		
		S = "ADOBECODEBANC"
		T = "ABC"
		Minimum window is "BANC"
	 * 
	 * 
	 * @param A
	 * @param B
	 * @return
	 */
	public String minWindow(String A, String B) {
        Map<Character, Integer> hash = new HashMap<Character, Integer>();
        for (int i=0; i<B.length(); i++) {
            Character c = B.charAt(i);
            hash.put(c,hash.containsKey(c) ? hash.get(c)+1 : 1);
        }
        int len = A.length();
        int indexI = 0, indexJ = -1;
        Map<Character, Integer> map = new HashMap<Character, Integer>(hash);
        while (indexI<len && !hash.containsKey(A.charAt(indexI))) indexI++;
        Map<Character, Integer> check = new HashMap<Character, Integer>();
        for (int i=indexI; i<len; i++) {
            Character c = A.charAt(i);
            if (map.containsKey(c)) {
                if (hash.containsKey(c)) {
                    if (hash.get(c) == 1) hash.remove(c);
                    else hash.put(c,hash.get(c)-1);
                } else {
                    check.put(c,check.containsKey(c) ? check.get(c)+1 : 1);
                }
            }
            if (hash.isEmpty()) {
                indexJ = i;
                break;
            }
        }
        if (indexI == len || indexJ == -1) return "";
        int minLength = indexJ + 1 - indexI;
        int i=indexI, j = indexJ;
        while (j < len) {
            Character c = A.charAt(i);
            i++;
            while (i<len && !map.containsKey(A.charAt(i))) i++;
            if (check.containsKey(c)) {
                if (check.get(c) == 1) check.remove(c);
                else check.put(c,check.get(c)-1);
            } else {
                j++;
                while (j<len && A.charAt(j) != c) {
                	if (map.containsKey(A.charAt(j))) {
                		check.put(A.charAt(j),check.containsKey(A.charAt(j)) ? check.get(A.charAt(j))+1 : 1);
                	}
                    j++;
                }
            }
            if (i<len && j<len && j+1-i < minLength) {
                indexI = i;
                indexJ = j;
                minLength = j+1-i;
            }
        }
        return A.substring(indexI,indexJ+1);
    }
	
	
	/**
	 * Given an array A of integers, find the index of values that satisfy A + B = C + D, where A,B,C & D are integers values in the array
	 * 
	 * 
	 * 
	 * 
	 * @param arr
	 * @return
	 */
	public ArrayList<Integer> equal_AB_CD(List<Integer> arr) {
        HashMap<Integer, LinkedList<Integer>> hash = new HashMap<Integer, LinkedList<Integer>>();
        int len = arr.size();
        ArrayList<Integer> lsorted = null;
        for (int i=0; i<len-1; i++) {
            for (int j=i+1; j<len; j++) {
                int sum = arr.get(i) + arr.get(j);
                if(hash.containsKey(sum)) {
                    if (i==hash.get(sum).get(0) || j==hash.get(sum).get(1) || j==hash.get(sum).get(0) || i==hash.get(sum).get(1)) continue;
                    ArrayList<Integer> ans = new ArrayList<Integer>(hash.get(sum));
                    ans.add(i);
                    ans.add(j);
                    if (lsorted == null) lsorted = ans;
                    else {
                        int temp = 0;
                        while (temp < 4){
                            if (lsorted.get(temp) > ans.get(temp)) {
                                lsorted = ans;
                                break;
                            } else if (lsorted.get(temp) < ans.get(temp)) break;
                            else ++temp;
                        }
                    }
                } else {
                    LinkedList<Integer> ll = new LinkedList<Integer>();
                    ll.add(i);ll.add(j);
                    hash.put(sum,ll);
                }
            }
        }
        return lsorted;
    }
	
	/**
	 * Given an array of strings, return all groups of strings that are anagrams. 
	 * Represent a group by a list of integers representing the index in the original list. 
	 * Look at the sample case for clarification.
	 * 
	 * Example :

		Input : cat dog god tca
		Output : [[1, 4], [2, 3]]
		cat and tca are anagrams which correspond to index 1 and 4. 
		dog and god are another set of anagrams which correspond to index 2 and 3.
	 * 
	 * 
	 * @param A
	 * @return
	 */
	public ArrayList<ArrayList<Integer>> anagrams(final List<String> A) {
        Map<Integer, Integer> hash = new HashMap<Integer, Integer>();
        ArrayList<ArrayList<Integer>> ans = new ArrayList<ArrayList<Integer>>();
        int len = A.size();
        for (int i=0; i<len; i++) {
            String str = A.get(i);
            Integer hashCode = hashCode(str);
            if (hash.containsKey(hashCode)) {
                ArrayList<Integer> l = new ArrayList<Integer>();
                l.add(hash.get(hashCode));
                l.add(i);
                ans.add(l);
            } else hash.put(hashCode,i);
        }
        return ans;
    }
	
	private Integer hashCode(String str) {
		ArrayList<Integer> primeMap = _26_Primes();
		Integer overflow = primeMap.remove(26);//not needed;
		//overflow = 2147483647;
		Integer hash = 1;
		char[] cArr = str.toCharArray();
		for (char c : cArr) {
			hash *= primeMap.get(c-'a');
			hash = hash%overflow;
		}
		return hash;
	}
	
	public ArrayList<Integer> _26_Primes() {
		int A = 103;
        ArrayList<Integer> res = new ArrayList<Integer>();
        int[] arr = new int[A+1];
        for (int i=2; i<A+1; i++) arr[i] = 1;
        
        int sqrt = (int)Math.sqrt(A);
        for (int i=2; i<=sqrt; i++) {
            if (arr[i] == 1) {
                for (int j=2; i*j<=A; j++) {
                    arr[i*j] = 0;
                }
            }
        }
        for (int i=2; i<=A; i++) {
            if (arr[i] == 1) res.add(i);
        }
        return res;
    }

	/**
	 * Given an array S of n integers, are there elements a, b, c, and d in S 
	 * such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.
	 * 
	 * O(n^3) ==> {this prints all pairs}
	 * 
	 * O(n^2) =========> https://www.geeksforgeeks.org/find-four-elements-sum-given-value-set-3-hashmap/ {This checks that if there exist two such pairs or not}
	 * 
	 * @param A
	 * @param target
	 * @return
	 */
	public ArrayList<ArrayList<Integer>> fourSum(List<Integer> A, int target) {
		Collections.sort(A);
        LinkedHashSet<ArrayList<Integer>> ans = new LinkedHashSet<ArrayList<Integer>>();
        int len = A.size();
        for (int i=0; i<len-3; i++) {
            for (int j=i+1; j<len-2; j++) {
                Integer sum = A.get(i)+A.get(j);
                Integer pair = target - sum;
                int indexI = j+1, indexJ = len-1;
                while (indexI < indexJ) {
                    int tempSum = A.get(indexI) +A.get(indexJ);
                    if (tempSum < pair) indexI++;
                    else if (tempSum > pair) indexJ--;
                    else {
                        ArrayList<Integer> arr = new ArrayList<Integer>();
                        arr.add(A.get(i));arr.add(A.get(j));
                        arr.add(A.get(indexI));arr.add(A.get(indexJ));
                        ans.add(arr);
                        indexI++;
                        indexJ--;
                    }
                }
            }
        }
        return new ArrayList<ArrayList<Integer>>(ans);
    }
	
	/**
	 * Given a string, 
		find the length of the longest substring without repeating characters.
		
		Example:
		
		The longest substring without repeating letters for "abcabcbb" is "abc", which the length is 3.
		
		For "bbbbb" the longest substring is "b", with the length of 1
	 * 
	 * 
	 * @param A
	 * @return
	 */
	public int lengthOfLongestSubstring(String A) {
        Map<Character, Integer> hash = new HashMap<Character, Integer>();
        int maxLength = 0;
        int localMax = 0;
        int startIndex = 0;
        for (int i=0; i<A.length(); i++) {
            Character c = A.charAt(i);
            if (hash.containsKey(c)) {
                int index = hash.get(c);
                if (index >=startIndex) {
                    int diff = index - startIndex;
                    startIndex = index+1;
                    maxLength = maxLength > localMax ? maxLength : localMax;
                    localMax -= diff;
                } else localMax++;
            } else localMax++;
            hash.put(c,i);
        }
        maxLength = maxLength > localMax ? maxLength : localMax;
        return maxLength;
        
        /**
         * HashSet<Character> hashSet = new HashSet<Character>();
        int maxCount = 0;
        int start = 0;
        for(char c : A.toCharArray()){
            while(hashSet.contains(c)){
                hashSet.remove(A.charAt(start));
                start++;
            }
            hashSet.add(c);
            maxCount = Math.max(maxCount, hashSet.size());
        }
        
        return maxCount;
         */
    }
	
	
	/**
	 * Find the largest continuous sequence in a array which sums to zero.

		Example:
		
		
		Input:  {1 ,2 ,-2 ,4 ,-4}
		Output: {2 ,-2 ,4 ,-4}
		
	 * @param A
	 * @return
	 */
	public ArrayList<Integer> longestSubsequenceSumZero(List<Integer> A) {
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        ArrayList<Integer> dup = new ArrayList<Integer>(A);
        map.put(0,-1);
        int indexI = -1, indexJ = -1;
        int sum = 0;
        for (int i=0; i<A.size(); i++) {
        	sum += A.get(i);
            if (map.containsKey(sum)) {
                if (indexJ == -1) {
                    indexI = map.get(sum) + 1;
                    indexJ = i;
                } else if (indexJ - indexI < i - map.get(sum) -1) {
                    indexI = map.get(sum) + 1;
                    indexJ = i;
                }
            } else {
            	map.put(sum,i);
            }
        }
        ArrayList<Integer> ans = new ArrayList<Integer>();
        if (indexI == -1 || indexJ == -1) return ans;
        while (indexI<=indexJ) {
        	ans.add(dup.get(indexI++));
        }
        return ans;
    }
	
	/**
	 * 
	 * @param A
	 * @param B
	 * @return
	 */
	public int diffPossible(final List<Integer> A, int B) {
        if (A == null || A.size() < 2) return 0;
        if (B == 0) {
        	Set<Integer> hash = new HashSet<Integer>();
        	for (Integer i : A) {
        		if (hash.contains(i)) return 1;
        		hash.add(i);
        	}
        	return 0;
        }
        Set<Integer> hash = new HashSet<Integer>(A);
        for (int i=0; i<A.size(); i++) {
            if (hash.contains(A.get(i)+B) || hash.contains(A.get(i)-B)) {
                return 1;
            }
        }
        return 0;
    }
	
	
	/**
	 * Given an array of integers, find two numbers such that they add up to a specific target number.

		The function twoSum should return indices of the two numbers such that they add up to the target, where index1 < index2. Please note that your returned answers (both index1 and index2 ) are not zero-based. 
		Put both these numbers in order in an array and return the array from your function ( Looking at the function signature will make things clearer ). Note that, if no pair exists, return empty list.
		
		If multiple solutions exist, output the one where index2 is minimum. If there are multiple solutions with the minimum index2, choose the one with minimum index1 out of them.
	 * 
	 * 
	 * @param A
	 * @param B
	 * @return
	 */
	public int[] twoSum(final int[] A, int B) {
        int[] ans = new int[2];
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        int first = -1, last = -1;
        for (int i=0; i<A.length; i++) {
            Integer p = B-A[i];
            if (map.containsKey(p)) {
                first = map.get(p);
                last = i;
                break;
            }
            if (!map.containsKey(A[i])) map.put(A[i],i);
        }
        ans[0] = first+1;
        ans[1] = last+1;
        return ans;
    }
	
	/**
	 * For Given Number N find if its COLORFUL number or not
	 * 
	 * A number can be broken into different contiguous sub-subsequence parts. 
		Suppose, a number 3245 can be broken into parts like 3 2 4 5 32 24 45 324 245. 
		And this number is a COLORFUL number, since product of every digit of a contiguous subsequence is different

	 * @param A
	 * @return
	 */
	public int colorful(int A) {
        String s = A+"";
        Set<Integer> hash = new HashSet<Integer>();
        for (int i=0; i<s.length(); i++) {
            Integer in = Integer.parseInt(s.charAt(i)+"");
            if (hash.contains(in)) return 0;
            hash.add(in);
            Integer prod = in;
            for (int j =i+1; j< s.length(); j++) {
                Integer inn = Integer.parseInt(s.charAt(j)+"");
                prod *= inn;
                if (hash.contains(prod)) return 0;
                hash.add(prod);
            }
        }
        return 1;
    }
}
